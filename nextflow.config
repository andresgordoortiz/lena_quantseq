// Profile config for CLIP cluster
params {
    config_profile_description = 'CLIP cluster profile'
    config_profile_contact = 'Andres Ortiz'
}

if (System.getenv("SLURM_CONF")) {
    process {
        executor = 'slurm'
        queue    = 'c'  // Default compute partition

        // Map time requirements to appropriate QoS
        clusterOptions = {
            def hours = task.time.toHours()
            if (hours <= 1) {
                return '--qos=c_rapid'
            } else if (hours <= 8) {
                return '--qos=c_short'
            } else if (hours <= 48) {
                return '--qos=c_medium'
            } else {
                return '--qos=c_long'
            }
        }
    }
} else {
    process {
        executor = 'local'
    }
}

singularity {
    enabled = true
    autoMounts = true
}

// Process-specific configuration
process {
    withName: 'NFCORE_RNASEQ:RNASEQ:DUPRADAR' {
        clusterOptions = {
            def baseOpts = (task.queue == 'c') ? {
                def hours = task.time.toHours()
                if (hours <= 1) return '--qos=c_rapid'
                else if (hours <= 8) return '--qos=c_short'
                else if (hours <= 48) return '--qos=c_medium'
                else return '--qos=c_long'
            }() : '--qos=c_short'
            return "${baseOpts} --mem=32G"
        }
        memory = '32.GB'
        time = '8.h'
        // Add Java options to increase stack size
        containerOptions = '--env _JAVA_OPTIONS="-Xss10m"'
    }

    // GPU partition processes with appropriate QoS
    withLabel: 'gpu' {
        queue = 'g'
        clusterOptions = {
            def hours = task.time.toHours()
            def qos
            if (hours <= 1) {
                qos = 'g_rapid'
            } else if (hours <= 8) {
                qos = 'g_short'
            } else if (hours <= 48) {
                qos = 'g_medium'
            } else {
                qos = 'g_long'
            }
            return "--gres=gpu:1 --qos=${qos}"
        }
    }

    // High-memory partition processes with appropriate QoS
    withLabel: 'highmem' {
        queue = 'm'
        clusterOptions = {
            def hours = task.time.toHours()
            def qos
            if (hours <= 1) {
                qos = 'm_rapid'
            } else if (hours <= 8) {
                qos = 'm_short'
            } else if (hours <= 48) {
                qos = 'm_medium'
            } else {
                qos = 'm_long'
            }
            return "--qos=${qos}"
        }
    }
}

process {
    // This applies to ALL processes in the pipeline
    errorStrategy = { task.exitStatus in [1, 135, 255, 143, 137, 104, 134, 139] ? 'retry' : 'finish' }
    maxRetries    = 3

    // Scale memory dynamically: starts at current memory and multiplies by attempt number
    memory = { task.memory ? task.memory * task.attempt : 12.GB * task.attempt }

    // Also scale CPUs to help with memory-intensive operations
    cpus = { task.cpus ? task.cpus * Math.min(task.attempt, 2) : 1 }

    // Optional: add a short delay before retrying to let the system "breathe"
    backOffStrategy = 'exponential'
}